```markdown
# order-events-schemas

## System Architecture Overview

**Workspace**: Default Workspace
**Architecture Style**: Microservices with event-driven communication
**This Component's Role**: Shared schema library for order-related events

## System-Wide Patterns

### Repository Pattern for Database Access
# Repository Pattern

All database access must go through repository classes to maintain clean separation of concerns.

## Structure
```typescript
// repositories/UserRepository.ts
export class UserRepository {
  constructor(private db: Database) {}

  async findById(id: string): Promise<User | null> {
    return this.db.users.findUnique({ where: { id } })
  }

  async create(data: CreateUserDto): Promise<User> {
    return this.db.users.create({ data })
  }

  async update(id: string, data: UpdateUserDto): Promise<User> {
    return this.db.users.update({ where: { id }, data })
  }
}
```

## Usage in Services
```typescript
// services/UserService.ts
export class UserService {
  constructor(private userRepo: UserRepository) {}

  async registerUser(email: string, password: string) {
    // Business logic here
    const hashedPassword = await hash(password)
    return this.userRepo.create({ email, password: hashedPassword })
  }
}
```

## Benefits
- Easy to mock for testing
- Database logic isolated
- Can swap ORMs easily
- Clear data access layer

## Component Details

**Purpose**: Shared TypeScript library providing type-safe event schemas for order-related events across microservices
**Tech Stack**: TypeScript (ES2022), CommonJS modules, NPM package (`@florea-alex/order-events-schemas`)
**Architecture**: Shared library pattern - provides common types, interfaces, and Zod schemas consumed by multiple services

**Key Directories**:
- `src/` - TypeScript source code for event schemas and type definitions
  - `src/events/` - Event schema definitions (base, order-created, order-confirmed, order-shipped, order-cancelled)
  - `src/helpers/` - Helper functions (createOrderEvent, validateEvent)
  - `src/topics.ts` - Kafka topic and consumer group constants
  - `src/index.ts` - Main barrel export file
- `dist/` - Compiled JavaScript output (generated by build)
- `tests/` - Jest test suite (41 tests, 80%+ coverage threshold)
- `node_modules/` - Dependencies

## Dependencies

**Runtime Dependencies**:
- `zod` (^3.22.0) - Schema validation library for runtime type checking

**Dev Dependencies**:
- `typescript` (^5.3.3) - TypeScript compiler
- `jest` (^29.7.0) - Testing framework
- `ts-jest` (^29.1.0) - TypeScript preprocessor for Jest
- `@types/jest` (^29.5.0) - TypeScript types for Jest
- `@types/node` (^20.0.0) - TypeScript types for Node.js

**Databases**: N/A - This is a schema library with no database access
**Message Queues**: N/A - Defines schemas used with Kafka but doesn't directly interact with it
**External APIs**: N/A - Pure schema library

## API Contracts

### REST Endpoints
N/A - This is a shared library, not a service with endpoints

### Events Published
N/A - This library defines schemas but doesn't publish events itself

### Events Consumed
N/A - This library defines schemas but doesn't consume events itself

**Event Schemas Defined**:

This library defines schemas for the following order lifecycle events:

1. **order.created** - Published when a new order is created
   - Fields: `orderId`, `userId`, `correlationId`, `timestamp`
   - Data: `items[]` (productId, quantity, price), `totalAmount`, `shippingAddress?`

2. **order.confirmed** - Published when an order is confirmed and payment succeeds
   - Fields: `orderId`, `userId`, `correlationId`, `timestamp`
   - Data: `items[]`, `totalAmount`, `paymentId?`

3. **order.shipped** - Published when an order is shipped
   - Fields: `orderId`, `userId`, `correlationId`, `timestamp`
   - Data: `trackingNumber?`, `carrier?`, `estimatedDelivery?`

4. **order.cancelled** - Published when an order is cancelled
   - Fields: `orderId`, `userId`, `correlationId`, `timestamp`
   - Data: `reason`, `cancelledBy` (user/system/admin), `refundAmount?`

**Kafka Constants**:
- Topic: `order.events` (`TOPICS.ORDER_EVENTS`)
- Consumer Groups:
  - `notification-worker-group` (`CONSUMER_GROUPS.NOTIFICATION_WORKER`)
  - `product-service-group` (`CONSUMER_GROUPS.PRODUCT_SERVICE`)

**Usage Pattern**:
```typescript
import {
  createOrderEvent,
  validateEvent,
  EVENT_TYPES,
  TOPICS,
  CONSUMER_GROUPS,
  OrderCreatedEvent,
  OrderConfirmedEvent,
  OrderShippedEvent,
  OrderCancelledEvent
} from '@florea-alex/order-events-schemas'

// Create a validated event
const event = createOrderEvent(EVENT_TYPES.ORDER_CREATED, {
  orderId: 123,
  userId: 456,
  data: {
    items: [{ productId: 1, quantity: 2, price: 19.99 }],
    totalAmount: 39.98
  }
});

// Validate an incoming event
const result = validateEvent(someEvent);
if (result.success) {
  // result.data contains the typed, validated event
}
```

## Conventions

### API Design Conventions
## REST API Conventions

### URL Structure
- Use plural nouns: `/users`, `/products`, `/orders`
- Nested resources: `/orders/:id/items`
- Use lowercase with hyphens: `/order-items`

### HTTP Methods
- `GET` - Retrieve resources
- `POST` - Create new resources
- `PUT` - Update entire resource
- `PATCH` - Partial update
- `DELETE` - Remove resource

### Response Format
```json
{
  "data": { },
  "error": null,
  "meta": { "page": 1, "total": 100 }
}
```

### Error Handling
- Return appropriate HTTP status codes
- Include error message and code in response body
- Log errors with correlation IDs

### Health Checks
All services expose `GET /health` returning `{ "status": "ok" }`

### API Response Format
# API Response Format

All API responses must follow this standard format:

```json
{
  "success": boolean,
  "data": any,
  "error": string | null,
  "timestamp": ISO8601
}
```

**Success responses:**
```json
{
  "success": true,
  "data": { ... },
  "error": null,
  "timestamp": "2026-02-08T11:00:00Z"
}
```

**Error responses:**
```json
{
  "success": false,
  "data": null,
  "error": "User not found",
  "timestamp": "2026-02-08T11:00:00Z"
}
```

### Environment Variables Naming
# Environment Variables Naming Convention

## Format
All environment variables must use `SCREAMING_SNAKE_CASE`.

## Prefixes by Category

### Database
- `DB_HOST`
- `DB_PORT`
- `DB_NAME`
- `DB_USER`
- `DB_PASSWORD`

### API/Service
- `API_PORT`
- `API_BASE_URL`
- `SERVICE_NAME`

### External Services
- `KAFKA_BROKERS`
- `REDIS_URL`
- `AWS_REGION`
- `STRIPE_API_KEY`

### Authentication
- `JWT_SECRET`
- `JWT_EXPIRY`
- `OAUTH_CLIENT_ID`
- `OAUTH_CLIENT_SECRET`

## Required in .env.example
Every service must have a `.env.example` file with all required variables (without values):
```bash
# .env.example
DB_HOST=
DB_PORT=
DB_NAME=
API_PORT=
JWT_SECRET=
```

## Validation
All environment variables should be validated at startup:
```typescript
const requiredEnvVars = ["DB_HOST", "DB_PORT", "API_PORT"]
requiredEnvVars.forEach(varName => {
  if (!process.env[varName]) {
    throw new Error(`Missing required env var: ${varName}`)
  }
})
```

### Task Creation Standards
# Task Creation Standards

When breaking down goals into tasks, follow this structure to ensure Developer agents can execute them successfully.

## Task Title Format
`[Action] [What] in [Component]`

Examples:
- ‚úÖ "Add user registration endpoint to user-service"
- ‚úÖ "Fix rate limiting bug in api-gateway"
- ‚úÖ "Implement order cancellation in order-service"
- ‚ùå "Registration" (too vague)
- ‚ùå "Fix bug" (no context)

## Task Description Structure

### 1. Objective (Required)
Clear statement of what needs to be accomplished.

### 2. Acceptance Criteria (Required)
Specific, measurable requirements. Use bullet points:
- Feature works as described
- Tests pass
- Follows conventions
- Handles edge cases
- Error handling implemented

### 3. Technical Notes (Recommended)
- Relevant patterns to follow (reference knowledge entries)
- Constraints and boundaries to respect
- Existing code to modify or extend
- Database schema if applicable
- API contracts with other services

### 4. Dependencies (If applicable)
- Tasks that must complete first
- External services or APIs needed
- Shared code or libraries required

### 5. Testing Requirements (Recommended)
- Unit tests for business logic
- Integration tests for API endpoints
- Edge cases to cover

## Example: Good Task

**Title:** Add user registration endpoint to user-service

**Description:**
Create POST /api/users/register endpoint in user-service.

Acceptance Criteria:
- Accepts `{ email, password, name }` in request body
- Validates email format (RFC 5322)
- Validates password strength (min 8 chars, 1 uppercase, 1 number, 1 special)
- Hashes password with bcrypt (cost factor 12)
- Stores user in database via UserRepository
- Returns user object (without password) using standard API Response Format
- Returns 201 on success
- Returns 400 with validation errors
- Returns 409 if email already exists
- Includes unit tests (90%+ coverage)
- Includes integration test

Technical Notes:
- Follow **Repository Pattern** convention for database access
- Use **API Response Format** convention for responses
- Use **Environment Variables Naming** for bcrypt cost factor (BCRYPT_ROUNDS)
- Reference: UserRepository already exists at `src/repositories/UserRepository.ts`
- Database: `users` table has columns: id, email, password_hash, name, created_at

Testing:
- Unit test: Valid registration
- Unit test: Invalid email format
- Unit test: Weak password
- Unit test: Duplicate email
- Integration test: Full registration flow

**Dependencies:** None

## Example: Bad Task

**Title:** Registration

**Description:**
Let users register

‚ùå Problems:
- Vague title (no action, no component)
- No acceptance criteria
- No technical details
- No testing requirements
- Developer must guess everything

## Task Sizing Guidelines

### ‚úÖ Good Size (1-3 hours)
- Single endpoint
- Single feature
- Specific bug fix
- Clear scope

### ‚ö†Ô∏è Too Large (split into smaller tasks)
- "Implement entire auth system"
- "Build user management"
- Multiple endpoints
- Affects 3+ files significantly

### ‚ö†Ô∏è Too Small (combine with related work)
- "Add a comment"
- "Fix typo"
- Trivial changes

## Referencing Knowledge

Always reference relevant knowledge entries:
- **Conventions**: Coding standards, patterns
- **Boundaries**: What NOT to do
- **ADRs**: Architectural decisions
- **Patterns**: Implementation approaches

Example:
```
Technical Notes:
- Follow Repository Pattern (see knowledge entry)
- Respect Gateway Database Boundary (no direct DB access)
- Use Kafka events per ADR-001 for order notifications
```

## When Developer Agents Execute

Developer agents will:
1. Read task description
2. Query MCP for relevant architecture context
3. Query MCP for referenced knowledge entries
4. Query MCP for component/repo details
5. Execute with full context

**Detailed tasks = successful execution!**

## Boundaries & Constraints

‚úÖ **Responsibilities**:
- Define and export TypeScript types/interfaces for order-related events
- Provide Zod schemas for runtime validation of event shapes
- Export constants for Kafka topics and consumer groups
- Provide helper functions (`createOrderEvent`, `validateEvent`) for type-safe event creation
- Maintain version compatibility across consuming services
- Provide comprehensive test coverage (80%+ threshold)
- Document event schemas and usage patterns

‚ùå **NOT Responsible For**:
- Publishing or consuming events (handled by individual services)
- Business logic (this is a pure schema library)
- Database operations or API implementations
- Kafka connection/producer/consumer setup

üö´ **Do NOT**:
- Add heavy runtime dependencies beyond Zod (keep this library lightweight)
- Include business logic or service-specific code
- Add environment-specific configuration
- Make breaking changes to exported types without version bump
- Add Kafka client libraries (services handle their own connections)

## Library Implementation Details

**Module System**: CommonJS (`module.exports`/`require`) to match existing services

**Exported Items**:
- Constants: `EVENT_TYPES`, `TOPICS`, `CONSUMER_GROUPS`
- Schemas: `BaseEventSchema`, `OrderCreatedSchema`, `OrderConfirmedSchema`, `OrderShippedSchema`, `OrderCancelledSchema`, `OrderItemSchema`
- Types: `EventType`, `BaseEvent`, `OrderCreatedEvent`, `OrderConfirmedEvent`, `OrderShippedEvent`, `OrderCancelledEvent`, `OrderItem`, `Topic`, `ConsumerGroup`
- Helpers: `createOrderEvent(type, params)`, `validateEvent(event)`

**Helper Function Behaviors**:
- `createOrderEvent()`: Auto-generates `correlationId` (UUID) and `timestamp` (ISO 8601) if not provided, validates against schema, throws ZodError on failure
- `validateEvent()`: Returns `{ success: boolean, data?: event, error?: Error }`, handles null/undefined gracefully

**Testing**: 41 Jest tests covering all schemas, helper functions, and edge cases

---

*This file was auto-generated by Atelier. Update it as the component evolves.*
```
